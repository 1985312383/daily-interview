import{_ as i,c as l,o as r,ag as e,j as t,a as n}from"./chunks/framework.UtM2fnOC.js";const m="/images/LightGBM.png",_=JSON.parse('{"title":"LightGBM面试题","description":"","frontmatter":{},"headers":[],"relativePath":"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md","filePath":"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md"}'),o={name:"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md"},s={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},f={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.909ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2611.7 1000","aria-hidden":"true"},d={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},T={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.909ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2611.7 1000","aria-hidden":"true"},Q={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},p={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.452ex"},xmlns:"http://www.w3.org/2000/svg",width:"27.149ex",height:"2.149ex",role:"img",focusable:"false",viewBox:"0 -750 12000 950","aria-hidden":"true"},g={tabindex:"0",class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},x={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-2.059ex"},xmlns:"http://www.w3.org/2000/svg",width:"47.92ex",height:"5.285ex",role:"img",focusable:"false",viewBox:"0 -1426 21180.4 2336","aria-hidden":"true"};function h(u,a,c,v,w,b){return r(),l("div",null,[a[19]||(a[19]=e("",22)),t("p",null,[a[6]||(a[6]=n("比如，我们在bundle中绑定了两个特征A和B，A特征的原始取值为区间 ",-1)),t("mjx-container",s,[(r(),l("svg",f,[...a[0]||(a[0]=[e("",1)])])),a[1]||(a[1]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"0"),t("mo",null,","),t("mn",null,"10"),t("mo",{stretchy:"false"},")")])],-1))]),a[7]||(a[7]=n("，B特征的原始取值为区间",-1)),t("mjx-container",d,[(r(),l("svg",T,[...a[2]||(a[2]=[e("",1)])])),a[3]||(a[3]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"0"),t("mo",null,","),t("mn",null,"20"),t("mo",{stretchy:"false"},")")])],-1))]),a[8]||(a[8]=n("，我们可以在B特征的取值上加一个偏置常�?0，将其取值范围变�?[10,30)",-1)),t("mjx-container",Q,[(r(),l("svg",p,[...a[4]||(a[4]=[e("",1)])])),a[5]||(a[5]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mi",null,"，"),t("mi",{mathvariant:"normal"},"绑"),t("mi",{mathvariant:"normal"},"定"),t("mi",{mathvariant:"normal"},"后"),t("mi",{mathvariant:"normal"},"的"),t("mi",{mathvariant:"normal"},"特"),t("mi",{mathvariant:"normal"},"征"),t("mi",{mathvariant:"normal"},"取"),t("mi",{mathvariant:"normal"},"值"),t("mi",{mathvariant:"normal"},"范"),t("mi",{mathvariant:"normal"},"围"),t("mi",{mathvariant:"normal"},"为")])],-1))]),a[9]||(a[9]=n("[0,30)$",-1))]),a[20]||(a[20]=t("h2",{id:"_7-lightgbm是怎么支持类别特征�",tabindex:"-1"},[n("7. LightGBM是怎么支持类别特征�? "),t("a",{class:"header-anchor",href:"#_7-lightgbm是怎么支持类别特征�","aria-label":'Permalink to "7. LightGBM是怎么支持类别特征�?"'},"​")],-1)),t("ul",null,[a[15]||(a[15]=t("li",null,[t("p",null,"离散特征建立直方图的过程"),t("p",null,"统计该特征下每一种离散值出现的次数，并从高到低排序，并过滤掉出现次数较少的特征�? 然后为每一个特征值，建立一个bin容器�?")],-1)),t("li",null,[a[14]||(a[14]=t("p",null,"计算分裂阈值的过程",-1)),t("ul",null,[a[13]||(a[13]=t("li",null,[t("p",null,"先看该特征下划分出的bin容器的个数，如果bin容器的数量小�?，直接使用one vs other方式, 逐个扫描每一个bin容器，找出最佳分裂点;")],-1)),t("li",null,[a[12]||(a[12]=t("p",null,"对于bin容器较多的情�? 先进行过滤，只让子集合较大的bin容器参加划分阈值计�? 对每一个符合条件的bin容器进行公式计算",-1)),t("mjx-container",g,[(r(),l("svg",x,[...a[10]||(a[10]=[e("",1)])])),a[11]||(a[11]=t("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[t("mfrac",null,[t("mrow",null,[t("mi",{mathvariant:"normal"},"该"),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"n"),t("mi",{mathvariant:"normal"},"容"),t("mi",{mathvariant:"normal"},"器"),t("mi",{mathvariant:"normal"},"下"),t("mi",{mathvariant:"normal"},"所"),t("mi",{mathvariant:"normal"},"有"),t("mi",{mathvariant:"normal"},"样"),t("mi",{mathvariant:"normal"},"本"),t("mi",{mathvariant:"normal"},"的"),t("mi",{mathvariant:"normal"},"一"),t("mi",{mathvariant:"normal"},"阶"),t("mi",{mathvariant:"normal"},"梯"),t("mi",{mathvariant:"normal"},"度"),t("mi",{mathvariant:"normal"},"之"),t("mi",null,"�"),t("mo",null,"?")]),t("mrow",null,[t("mi",{mathvariant:"normal"},"该"),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"n"),t("mi",{mathvariant:"normal"},"容"),t("mi",{mathvariant:"normal"},"器"),t("mi",{mathvariant:"normal"},"下"),t("mi",{mathvariant:"normal"},"所"),t("mi",{mathvariant:"normal"},"有"),t("mi",{mathvariant:"normal"},"样"),t("mi",{mathvariant:"normal"},"本"),t("mi",{mathvariant:"normal"},"的"),t("mi",{mathvariant:"normal"},"二"),t("mi",{mathvariant:"normal"},"阶"),t("mi",{mathvariant:"normal"},"梯"),t("mi",{mathvariant:"normal"},"度"),t("mi",{mathvariant:"normal"},"之"),t("mi",{mathvariant:"normal"},"和")])]),t("mo",null,"+"),t("mi",{mathvariant:"normal"},"正"),t("mi",{mathvariant:"normal"},"则"),t("mi",null,"�"),t("mo",null,"?")])],-1))])])])]),a[16]||(a[16]=t("li",null,[t("p",null,[t("strong",null,"这里为什么不是label的均值呢？其�?label的均�?只是为了便于理解，只针对了学习一棵树且是回归问题的情况， 这时候一阶导数是Y, 二阶导数�?"),n(")，得到一个值，根据该值对bin容器从小到大进行排序，然后分从左到右、从右到左进行搜索，得到最优分裂阈值。但是有一点，没有搜索所有的bin容器，而是设定了一个搜索bin容器数量的上限值，程序中设定是32，即参数max_num_cat�?")])],-1)),a[17]||(a[17]=t("li",null,[t("p",null,"LightGBM中对离散特征实行的是many vs many 策略，这32个bin中最优划分的阈值的左边或者右边所有的bin容器就是一个many集合，而其他的bin容器就是另一个many集合�?")],-1)),a[18]||(a[18]=t("li",null,[t("p",null,"对于连续特征，划分阈值只有一个，对于离散值可能会有多个划分阈值，每一个划分阈值对应着一个bin容器编号，当使用离散特征进行分裂时，只要数据样本对应的bin容器编号在这些阈值对应的bin集合之中，这条数据就加入分裂后的左子树，否则加入分裂后的右子树�?")],-1))]),a[21]||(a[21]=e("",13))])}const M=i(o,[["render",h]]);export{_ as __pageData,M as default};
